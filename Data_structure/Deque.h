template <class T>
struct Deque_elem // Элемент двунаправленной очереди
{
	T data; // Какие-то данные
	Deque_elem<T> *next = NULL; // Указатель на следующий элемент очереди
	Deque_elem<T> *prev = NULL; // Указатель на предыдущий элемент очереди
};


template <class T>
struct Deque // Двунаправленная очередь
{
	Deque_elem<T> *head = NULL; // Указатель на первый (верхний) элемент очереди
	Deque_elem<T> *tail = NULL; // Указатель на последний (нижний) элемент очереди
};


/*		Принимает указатель на очередь, и элемент - данные, которые нужно записать в очередь.
	Добавляет данные в начало (наверх) очереди:
	создает новый элемент очереди, в который записывает данные, связывает его с первым элементов очереди так, что новый элемент становится первым в очереди.
	Если элементов в очереди не было, создает элемент и записывает туда переданные данные.		*/
template <class T>
void AddtoTop(Deque<T> *deque, T data)
{
	if (deque->head == NULL) // Если очередь пустая (первого элемента в очереди нет)
	{
		Deque_elem<T> *tmp = new Deque_elem<T>; // Создаем новый элемент очереди
		deque->head = deque->tail = tmp; // Указателям на первый и последний элементы очереди присваиваем указатель на новы элемент
		deque->head->data = data; // Заполняем новосозданный элемент
	}
	else // Если очередь не пустая
	{
		Deque_elem<T> *tmp = new Deque_elem<T>; // Создаем новый элемент очереди
		tmp->data = data; // Заполняем новосозданный элемент
		deque->head->next = tmp; // Указателю на следующий элемент присваиваем указатель на новый элемент
		tmp->prev = deque->head; // Указателю нового элемента на предыдущий присваиваем указатель на верхний элемент очереди
		deque->head = tmp; // Смещаемся на новый элемент, теперь он и есть самый верхний в очереди
	}
}


/*		Принимает указатель на очередь, и элемент - данные, которые нужно записать в очередь.
	Добавляет данные в конец (вниз) очереди:
	создает новый элемент очереди, в который записывает данные, связывает его с последним элементов очереди так, что новый элемент становится последним в очереди.
	Если элементов в очереди не было, создает элемент и записывает туда переданные данные.		*/
template <class T>
void AddtoEnd(Deque<T> *deque, T data)
{
	if (deque->tail == NULL) // Если очередь пустая (последнего элемента в очереди нет)
	{
		Deque_elem<T> *tmp = new Deque_elem<T>; // Создаем новый элемент очереди
		deque->head = deque->tail = tmp; // Указателям на первый и последний элементы очереди присваиваем указатель на новы элемент
		deque->tail->data = data; // Заполняем новосозданный элемент
	}
	else // Если очередь не пустая
	{
		Deque_elem<T> *tmp = new Deque_elem<T>; // Создаем новый элемент очереди
		tmp->data = data; // Заполняем его данными
		deque->tail->prev = tmp; // Указателю на предыдущий элемент присваиваем указатель на новый элемент
		tmp->next = deque->tail; // Указателю нового элемента на следующий элемент присваиваем указатель на последний элемент очереди
		deque->tail = tmp; // Смещаемся на новый элемент, теперь он и есть самый последний (нижний) в очереди
	}
}


// Принимает указатель на очередь. Удаляет и взвращает самый последний (нижний) элемент очереди. **Не передевать указатель на пустую очередь ** 
template <class T>
T GetfromEnd(Deque<T> *deque)
{
	T data = deque->tail->data; // Копируем данные из элемента очереди в переменную

	Deque_elem<T> *tail = deque->tail; // Создаем указатель на последний элемент очереди
	deque->tail = deque->tail->next; // Перемещаемся к следующему (предпоследнему) элементу очереди

	if (deque->tail == NULL) // Если предпоследнего элемента очереди нет
		deque->head = NULL; // Удаляем указатель на первый элемент очереди (элементов в очереди больше нет)

	delete tail; // Освобождаем память, занятую под последний элемент очереди

	return data;
}


// Принимает указатель на очередь. Удаляет и взвращает самый первый (верхний) элемент очереди. **Не передевать указатель на пустую очередь ** 
template <class T>
T GetfromTop(Deque<T> *deque)
{
	T data = deque->head->data; // Копируем данные из элемента очереди в переменную
	Deque_elem<T> *head = deque->head; // Создаем указатель на первый элемент очереди
	deque->head = deque->head->prev; // Перемещаемся к предыдущему (второму) элементу очереди

	if (deque->head == NULL) // Если второго элемента очереди нет
		deque->tail = NULL; // Удаляем указатель на последний элемент очереди (элементов в очереди больше нет)

	delete head; // Освобождаем память, занятую под первый элемент очереди

	return data;
}