#include"Poisk.h"
char *Sozd(int b)//b - это количество элементов в строке.
{
	char*a = new char[b];
	return a;
}

void Vyvod(char*a,int b)//a - это строка; b - это количество элементов в строке.
{
	for (int i=0;i<b;i++)
		cout<<" "<<a[i];
	cout<<"\n";
}

int Stop(char*c,int d,char e)//c - это строка, в которой ведётся поиск стоп-символов; d - это количество элементов в этой строке;
//e - это искомый стоп-символ.
{
	int st=0;//st - это порядковый номер элемента, равного стоп-символу.
	for (int i=0;i<d-1;i++)
		if (c[i]==e)
			st=i+1;
	return st;
}

int VEvr(char*a,char*c,int b,int f)//a - это искомый шаблон; c - это суффикс, искомый в шаблоне; b - это количество элементов в шаблоне;
//f - это количество элементов в суффиксе.
{
	int i=b-1-f,j=f-1,kol=0,gr=0,per=0;//i - это индекс элемента шаблона; j - это индекс элемента суффикса; kol - это количество совпавших элементов
//в шаблоне и суффиксе; gr - это граница суффикса от начала (если суффикс нужно будет уменьшить); per - это количество элементов, на которое надо
//будет переместить шаблон относительно строки.
	while ((i>=f-1-gr) && (j>=gr))
	{
		if (a[i]==c[j])
		{
			kol+=1;
			if (j==gr)
			{
				per=b-kol;
				j--;
			}
			else
			{
				i--;
				j--;
			}
		}
		else
		{
			if (i==f-1-gr)
			{
				if (kol>1)
				{
					gr+=1;
					i=b-1-f+gr;
					j=f-1;
					kol=0;
				}
				else
					i--;
			}
			else
			{
				i--;
				kol=0;
			}
		}
	}
	return per;
}

void PEvr(char*a,char*c,int b,int d)//a - это исходная строка; c - это шаблон; b - это количество элементов в строке; d - это количество элементов
//в шаблоне.
{
	int sim,i=d-1,j=d-1,sov=0,suf;//sim - это стоп-символ; i - это индекс элементов исходной строки; j - это индекс элементов шаблона;
//sov - это количество совпавших элементов подряд; suf - это суффикс шаблона.
	char* s;//s - это строка для суффикса.
	while ((i<b) && (j>=0))
	{
		if (a[i]==c[j])
		{
			sov+=1;
			if (j==0)
			{
				cout<<"\n   Индекс первого вхождения искомого шаблона: "<<i<<"\n";
				i--;
				j--;
			}
			else
			{
				i--;
				j--;
			}
		}
		else
		{
			if ((sov>1) && (sov<b/2))
			{
				s=Sozd(sov);
				for (int i=0,j=d-sov;i<sov,j<d;i++,j++)
					s[i]=c[j];
				suf=VEvr(c,s,d,sov);
				i+=d-suf;
			}
			else
			{
				sim=Stop(c,d,a[i]);
				if (i==b-1)
				{
					cout<<"\n   Шаблон не найден!\n";
					i++;
				}
				else
				{
					if (sim==0)
					{
						i+=d;
						j=d-1;
					}
					else
					{
						i+=d-sim;
						j=d-1;
					}
				}
			}
		}
	}
}
